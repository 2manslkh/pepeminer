{
  "language": "Solidity",
  "sources": {
    "contracts/PepeMiner.sol": {
      "content": "// SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.12;\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n\ncontract PepeMiner is ReentrancyGuard {\n    uint256 public EGGS_TO_HATCH_1MINERS = 864000;\n    uint256 PSN = 10000;\n    uint256 PSNH = 5000;\n    bool public initialized = false;\n\n    address public treasuryAddress;\n    address public owner;\n\n    mapping(address => uint256) public hatcheryMiners;\n    mapping(address => uint256) public claimedChickens;\n    mapping(address => uint256) public lastHatch;\n    mapping(address => uint256) public lastWithdraw;\n    mapping(address => address) public referrals;\n\n    uint256 constant HATCH_STEP = 1 days;\n    uint256 constant HATCH_STEP_MODIFIER = 0.1e18;\n    uint256 constant BASE_PERCENTAGE = 0.5e18;\n\n    uint256 public marketChickens;\n\n    bool public canAirdrop = true;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        treasuryAddress = address(0x420694bc7D762ba3Bc0784af0d87dbf63f2F266A);\n    }\n\n    function stopAirdrop() public onlyOwner {\n        canAirdrop = false;\n    }\n\n    function airdropChickens(address[] memory addresses, uint256 _amount) public onlyOwner {\n        require(canAirdrop, \"airdrop is stopped\");\n\n        for (uint256 i = 0; i < addresses.length; i++) {\n            hatcheryMiners[addresses[i]] += _amount;\n        }\n\n        marketChickens += (_amount * addresses.length);\n    }\n\n    function compound(address ref) public nonReentrant {\n        require(initialized);\n        if (ref == msg.sender) {\n            ref = address(0);\n        }\n        if (referrals[msg.sender] == address(0) && referrals[msg.sender] != msg.sender) {\n            referrals[msg.sender] = ref;\n        }\n        uint256 chickensUsed = getMyChickens();\n\n        uint256 newMiners = chickensUsed / EGGS_TO_HATCH_1MINERS;\n        hatcheryMiners[msg.sender] += newMiners;\n        claimedChickens[msg.sender] = 0;\n        lastHatch[msg.sender] = block.timestamp;\n\n        //send referral chickens\n        claimedChickens[referrals[msg.sender]] += chickensUsed / 10;\n\n        //boost market to nerf miners hoarding\n        marketChickens += chickensUsed / 2;\n    }\n\n    function withdraw() public nonReentrant {\n        require(initialized);\n        uint256 hasChickens = getMyChickens();\n\n        require(hasChickens > 0, \"no chickens\");\n        uint256 chickenValue = calculateChickenSell(hasChickens);\n        uint256 fee = devFee(chickenValue);\n\n        claimedChickens[msg.sender] = 0;\n        lastHatch[msg.sender] = block.timestamp;\n        lastWithdraw[msg.sender] = block.timestamp;\n\n        // boost market to nerf miners hoarding\n        marketChickens += hasChickens;\n\n        payable(treasuryAddress).call{ value: fee }(\"\");\n        payable(msg.sender).call{ value: chickenValue - fee }(\"\");\n    }\n\n    function deposit(address ref) public payable {\n        require(initialized, \"not initialized\");\n\n        uint256 chickensBought = calculateChickenBuy(msg.value, address(this).balance - msg.value);\n\n        chickensBought -= devFee(chickensBought);\n        uint256 fee = devFee(msg.value);\n\n        payable(treasuryAddress).call{ value: fee }(\"\");\n\n        claimedChickens[msg.sender] += chickensBought;\n\n        compound(ref);\n    }\n\n    //magic trade balancing algorithm\n    function calculateTrade(uint256 rt, uint256 rs, uint256 bs) public view returns (uint256) {\n        return (PSN * bs) / (PSNH + ((PSN * rs + PSNH * rt) / rt));\n    }\n\n    function calculateChickenSell(uint256 chickens) public view returns (uint256) {\n        if (chickens == 0) return 0;\n        return calculateTrade(chickens, marketChickens, address(this).balance);\n    }\n\n    function calculateChickenBuy(uint256 eth, uint256 contractBalance) public view returns (uint256) {\n        return calculateTrade(eth, contractBalance, marketChickens);\n    }\n\n    function calculateChickenBuySimple(uint256 eth) public view returns (uint256) {\n        return calculateChickenBuy(eth, address(this).balance);\n    }\n\n    function devFee(uint256 amount) public pure returns (uint256) {\n        return (amount * 5) / 100;\n    }\n\n    function seedMarket() public payable {\n        require(marketChickens == 0);\n        initialized = true;\n        marketChickens = 86400000000;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function getMyMiners() public view returns (uint256) {\n        return hatcheryMiners[msg.sender];\n    }\n\n    function getMyChickens() public view returns (uint256) {\n        return claimedChickens[msg.sender] + getChickensSinceLastHatch(msg.sender);\n    }\n\n    function getChickensSinceLastHatch(address adr) public view returns (uint256) {\n        uint256 steps = (block.timestamp - lastWithdraw[msg.sender]) / HATCH_STEP;\n\n        // the percentage is capped at 100%\n        // it takes 1 day to reach 100% after a withdrawal\n        uint256 percentage = min(1e18, BASE_PERCENTAGE + steps * HATCH_STEP_MODIFIER);\n\n        uint256 secondsPassed = min(EGGS_TO_HATCH_1MINERS, block.timestamp - lastHatch[adr]);\n        return ((secondsPassed * hatcheryMiners[adr]) * percentage) / 1e18;\n    }\n\n    function getHalvingPercentage() public view returns (uint256) {\n        uint256 steps = (block.timestamp - lastWithdraw[msg.sender]) / HATCH_STEP;\n\n        return min(1e18, BASE_PERCENTAGE + steps * HATCH_STEP_MODIFIER);\n    }\n\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}